// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: prices.sql

package db

import (
	"context"
	"time"
)

const getHighestPriceAfterDate = `-- name: GetHighestPriceAfterDate :one
SELECT price, recorded_at
FROM ticker_prices
WHERE ticker_id = $1 AND recorded_at >= $2
ORDER BY price DESC
LIMIT 1
`

type GetHighestPriceAfterDateParams struct {
	TickerID   int64     `json:"ticker_id"`
	RecordedAt time.Time `json:"recorded_at"`
}

type GetHighestPriceAfterDateRow struct {
	Price      string    `json:"price"`
	RecordedAt time.Time `json:"recorded_at"`
}

func (q *Queries) GetHighestPriceAfterDate(ctx context.Context, arg GetHighestPriceAfterDateParams) (GetHighestPriceAfterDateRow, error) {
	row := q.db.QueryRowContext(ctx, getHighestPriceAfterDate, arg.TickerID, arg.RecordedAt)
	var i GetHighestPriceAfterDateRow
	err := row.Scan(&i.Price, &i.RecordedAt)
	return i, err
}

const getLatestTickerPrice = `-- name: GetLatestTickerPrice :one
SELECT price, recorded_at
FROM ticker_prices
WHERE ticker_id = $1
ORDER BY recorded_at DESC
LIMIT 1
`

type GetLatestTickerPriceRow struct {
	Price      string    `json:"price"`
	RecordedAt time.Time `json:"recorded_at"`
}

func (q *Queries) GetLatestTickerPrice(ctx context.Context, tickerID int64) (GetLatestTickerPriceRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestTickerPrice, tickerID)
	var i GetLatestTickerPriceRow
	err := row.Scan(&i.Price, &i.RecordedAt)
	return i, err
}

const getTickerPriceByDate = `-- name: GetTickerPriceByDate :one
SELECT id, price, recorded_at
FROM ticker_prices
WHERE ticker_id = $1 AND DATE(recorded_at) = DATE($2)
`

type GetTickerPriceByDateParams struct {
	TickerID int64       `json:"ticker_id"`
	Date     interface{} `json:"date"`
}

type GetTickerPriceByDateRow struct {
	ID         int64     `json:"id"`
	Price      string    `json:"price"`
	RecordedAt time.Time `json:"recorded_at"`
}

func (q *Queries) GetTickerPriceByDate(ctx context.Context, arg GetTickerPriceByDateParams) (GetTickerPriceByDateRow, error) {
	row := q.db.QueryRowContext(ctx, getTickerPriceByDate, arg.TickerID, arg.Date)
	var i GetTickerPriceByDateRow
	err := row.Scan(&i.ID, &i.Price, &i.RecordedAt)
	return i, err
}

const insertTickerPrice = `-- name: InsertTickerPrice :one
INSERT INTO ticker_prices (ticker_id, price, volume, recorded_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (ticker_id, recorded_at) DO UPDATE SET price = EXCLUDED.price, volume = EXCLUDED.volume
RETURNING id, ticker_id, price, recorded_at, volume
`

type InsertTickerPriceParams struct {
	TickerID   int64     `json:"ticker_id"`
	Price      string    `json:"price"`
	Volume     int64     `json:"volume"`
	RecordedAt time.Time `json:"recorded_at"`
}

func (q *Queries) InsertTickerPrice(ctx context.Context, arg InsertTickerPriceParams) (TickerPrice, error) {
	row := q.db.QueryRowContext(ctx, insertTickerPrice,
		arg.TickerID,
		arg.Price,
		arg.Volume,
		arg.RecordedAt,
	)
	var i TickerPrice
	err := row.Scan(
		&i.ID,
		&i.TickerID,
		&i.Price,
		&i.RecordedAt,
		&i.Volume,
	)
	return i, err
}

const tickerPriceExistsForDate = `-- name: TickerPriceExistsForDate :one
SELECT EXISTS(
  SELECT 1 FROM ticker_prices
  WHERE ticker_id = $1 AND DATE(recorded_at) = DATE($2)
) AS exists
`

type TickerPriceExistsForDateParams struct {
	TickerID int64       `json:"ticker_id"`
	Date     interface{} `json:"date"`
}

func (q *Queries) TickerPriceExistsForDate(ctx context.Context, arg TickerPriceExistsForDateParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, tickerPriceExistsForDate, arg.TickerID, arg.Date)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
