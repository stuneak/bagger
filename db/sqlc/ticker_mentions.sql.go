// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ticker_mentions.sql

package db

import (
	"context"
	"time"
)

const createTickerMention = `-- name: CreateTickerMention :one
INSERT INTO ticker_mentions (
  ticker_id,
  user_id,
  comment_id,
  mentioned_at
)
VALUES ($1, $2, $3, $4)
RETURNING id, ticker_id, user_id, comment_id, mentioned_at
`

type CreateTickerMentionParams struct {
	TickerID    int64     `json:"ticker_id"`
	UserID      int64     `json:"user_id"`
	CommentID   int64     `json:"comment_id"`
	MentionedAt time.Time `json:"mentioned_at"`
}

func (q *Queries) CreateTickerMention(ctx context.Context, arg CreateTickerMentionParams) (TickerMention, error) {
	row := q.db.QueryRowContext(ctx, createTickerMention,
		arg.TickerID,
		arg.UserID,
		arg.CommentID,
		arg.MentionedAt,
	)
	var i TickerMention
	err := row.Scan(
		&i.ID,
		&i.TickerID,
		&i.UserID,
		&i.CommentID,
		&i.MentionedAt,
	)
	return i, err
}

const getAllMentionsComplete = `-- name: GetAllMentionsComplete :many
SELECT
  tn.symbol,
  u.username,
  COALESCE(mention_price.price::text, '0') AS mention_price,
  COALESCE(current_price.price::text, '0') AS current_price,
  COALESCE(current_price.recorded_at, now()) AS current_price_date,
  tm.mentioned_at,
  COALESCE((
    SELECT EXP(SUM(LN(ts.ratio::double precision)))
    FROM ticker_splits ts
    WHERE ts.ticker_id = tm.ticker_id
      AND ts.effective_date >= tm.mentioned_at
      AND ts.effective_date <= COALESCE(current_price.recorded_at, now())
  ), 1.0)::double precision AS split_ratio
FROM ticker_mentions tm
JOIN users u ON u.id = tm.user_id
JOIN ticker_names tn ON tn.id = tm.ticker_id
LEFT JOIN LATERAL (
  SELECT price, recorded_at
  FROM ticker_prices
  WHERE ticker_id = tm.ticker_id AND recorded_at <= tm.mentioned_at
  ORDER BY recorded_at DESC
  LIMIT 1
) mention_price ON true
LEFT JOIN LATERAL (
  SELECT price, recorded_at
  FROM ticker_prices
  WHERE ticker_id = tm.ticker_id
  ORDER BY recorded_at DESC
  LIMIT 1
) current_price ON true
WHERE tm.mentioned_at >= $1
ORDER BY tm.mentioned_at ASC
`

type GetAllMentionsCompleteRow struct {
	Symbol           string      `json:"symbol"`
	Username         string      `json:"username"`
	MentionPrice     interface{} `json:"mention_price"`
	CurrentPrice     interface{} `json:"current_price"`
	CurrentPriceDate time.Time   `json:"current_price_date"`
	MentionedAt      time.Time   `json:"mentioned_at"`
	SplitRatio       float64     `json:"split_ratio"`
}

func (q *Queries) GetAllMentionsComplete(ctx context.Context, mentionedAt time.Time) ([]GetAllMentionsCompleteRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMentionsComplete, mentionedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMentionsCompleteRow
	for rows.Next() {
		var i GetAllMentionsCompleteRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Username,
			&i.MentionPrice,
			&i.CurrentPrice,
			&i.CurrentPriceDate,
			&i.MentionedAt,
			&i.SplitRatio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMentionsComplete = `-- name: GetUserMentionsComplete :many
SELECT
  tn.symbol,
  COALESCE(mention_price.price::text, '0') AS mention_price,
  COALESCE(current_price.price::text, '0') AS current_price,
  COALESCE(current_price.recorded_at, now()) AS current_price_date,
  tm.mentioned_at,
  COALESCE((
    SELECT EXP(SUM(LN(ts.ratio::double precision)))
    FROM ticker_splits ts
    WHERE ts.ticker_id = tm.ticker_id
      AND ts.effective_date >= tm.mentioned_at
      AND ts.effective_date <= COALESCE(current_price.recorded_at, now())
  ), 1.0)::double precision AS split_ratio
FROM (
  SELECT DISTINCT ON (ticker_id) ticker_id, mentioned_at
  FROM ticker_mentions
  WHERE user_id = (SELECT id FROM users WHERE username = $1)
    AND mentioned_at >= $2
  ORDER BY ticker_id, mentioned_at ASC
) tm
JOIN ticker_names tn ON tn.id = tm.ticker_id
LEFT JOIN LATERAL (
  SELECT price, recorded_at
  FROM ticker_prices
  WHERE ticker_id = tm.ticker_id AND recorded_at <= tm.mentioned_at
  ORDER BY recorded_at DESC
  LIMIT 1
) mention_price ON true
LEFT JOIN LATERAL (
  SELECT price, recorded_at
  FROM ticker_prices
  WHERE ticker_id = tm.ticker_id
  ORDER BY recorded_at DESC
  LIMIT 1
) current_price ON true
ORDER BY tn.symbol
`

type GetUserMentionsCompleteParams struct {
	Username    string    `json:"username"`
	MentionedAt time.Time `json:"mentioned_at"`
}

type GetUserMentionsCompleteRow struct {
	Symbol           string      `json:"symbol"`
	MentionPrice     interface{} `json:"mention_price"`
	CurrentPrice     interface{} `json:"current_price"`
	CurrentPriceDate time.Time   `json:"current_price_date"`
	MentionedAt      time.Time   `json:"mentioned_at"`
	SplitRatio       float64     `json:"split_ratio"`
}

func (q *Queries) GetUserMentionsComplete(ctx context.Context, arg GetUserMentionsCompleteParams) ([]GetUserMentionsCompleteRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMentionsComplete, arg.Username, arg.MentionedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserMentionsCompleteRow
	for rows.Next() {
		var i GetUserMentionsCompleteRow
		if err := rows.Scan(
			&i.Symbol,
			&i.MentionPrice,
			&i.CurrentPrice,
			&i.CurrentPriceDate,
			&i.MentionedAt,
			&i.SplitRatio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
