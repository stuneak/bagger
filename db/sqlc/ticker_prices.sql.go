// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ticker_prices.sql

package db

import (
	"context"
	"time"
)

const deleteTickerPriceByDate = `-- name: DeleteTickerPriceByDate :exec
DELETE FROM ticker_prices
WHERE ticker_id = $1 AND DATE(recorded_at) = DATE($2)
`

type DeleteTickerPriceByDateParams struct {
	TickerID int64       `json:"ticker_id"`
	Date     interface{} `json:"date"`
}

func (q *Queries) DeleteTickerPriceByDate(ctx context.Context, arg DeleteTickerPriceByDateParams) error {
	_, err := q.db.ExecContext(ctx, deleteTickerPriceByDate, arg.TickerID, arg.Date)
	return err
}

const insertTickerPrice = `-- name: InsertTickerPrice :one
INSERT INTO ticker_prices (ticker_id, price, volume, recorded_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (ticker_id, recorded_at) DO UPDATE SET price = EXCLUDED.price, volume = EXCLUDED.volume
RETURNING id, ticker_id, price, recorded_at, volume
`

type InsertTickerPriceParams struct {
	TickerID   int64     `json:"ticker_id"`
	Price      string    `json:"price"`
	Volume     int64     `json:"volume"`
	RecordedAt time.Time `json:"recorded_at"`
}

func (q *Queries) InsertTickerPrice(ctx context.Context, arg InsertTickerPriceParams) (TickerPrice, error) {
	row := q.db.QueryRowContext(ctx, insertTickerPrice,
		arg.TickerID,
		arg.Price,
		arg.Volume,
		arg.RecordedAt,
	)
	var i TickerPrice
	err := row.Scan(
		&i.ID,
		&i.TickerID,
		&i.Price,
		&i.RecordedAt,
		&i.Volume,
	)
	return i, err
}
