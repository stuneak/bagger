// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: splits.sql

package db

import (
	"context"
	"time"
)

const getAllSplits = `-- name: GetAllSplits :many
SELECT ticker_id, ratio, effective_date
FROM stock_splits
ORDER BY ticker_id, effective_date
`

type GetAllSplitsRow struct {
	TickerID      int64     `json:"ticker_id"`
	Ratio         string    `json:"ratio"`
	EffectiveDate time.Time `json:"effective_date"`
}

func (q *Queries) GetAllSplits(ctx context.Context) ([]GetAllSplitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSplits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSplitsRow
	for rows.Next() {
		var i GetAllSplitsRow
		if err := rows.Scan(&i.TickerID, &i.Ratio, &i.EffectiveDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsBetweenDates = `-- name: GetSplitsBetweenDates :many
SELECT ratio, effective_date
FROM stock_splits
WHERE ticker_id = $1
  AND effective_date >= $2::date
  AND effective_date <= $3
ORDER BY effective_date
`

type GetSplitsBetweenDatesParams struct {
	TickerID      int64     `json:"ticker_id"`
	Column2       time.Time `json:"column_2"`
	EffectiveDate time.Time `json:"effective_date"`
}

type GetSplitsBetweenDatesRow struct {
	Ratio         string    `json:"ratio"`
	EffectiveDate time.Time `json:"effective_date"`
}

func (q *Queries) GetSplitsBetweenDates(ctx context.Context, arg GetSplitsBetweenDatesParams) ([]GetSplitsBetweenDatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSplitsBetweenDates, arg.TickerID, arg.Column2, arg.EffectiveDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSplitsBetweenDatesRow
	for rows.Next() {
		var i GetSplitsBetweenDatesRow
		if err := rows.Scan(&i.Ratio, &i.EffectiveDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByTicker = `-- name: GetSplitsByTicker :many
SELECT id, ticker_id, ratio, effective_date, created_at
FROM stock_splits
WHERE ticker_id = $1
ORDER BY effective_date DESC
`

func (q *Queries) GetSplitsByTicker(ctx context.Context, tickerID int64) ([]StockSplit, error) {
	rows, err := q.db.QueryContext(ctx, getSplitsByTicker, tickerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockSplit
	for rows.Next() {
		var i StockSplit
		if err := rows.Scan(
			&i.ID,
			&i.TickerID,
			&i.Ratio,
			&i.EffectiveDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStockSplit = `-- name: InsertStockSplit :exec
INSERT INTO stock_splits (ticker_id, ratio, effective_date)
VALUES ($1, $2, $3)
ON CONFLICT (ticker_id, effective_date) DO NOTHING
`

type InsertStockSplitParams struct {
	TickerID      int64     `json:"ticker_id"`
	Ratio         string    `json:"ratio"`
	EffectiveDate time.Time `json:"effective_date"`
}

func (q *Queries) InsertStockSplit(ctx context.Context, arg InsertStockSplitParams) error {
	_, err := q.db.ExecContext(ctx, insertStockSplit, arg.TickerID, arg.Ratio, arg.EffectiveDate)
	return err
}
